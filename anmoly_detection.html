<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Anamoly detection with Machine Learning Overview</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="anmoly_detection_files/libs/clipboard/clipboard.min.js"></script>
<script src="anmoly_detection_files/libs/quarto-html/quarto.js"></script>
<script src="anmoly_detection_files/libs/quarto-html/popper.min.js"></script>
<script src="anmoly_detection_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="anmoly_detection_files/libs/quarto-html/anchor.min.js"></script>
<link href="anmoly_detection_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="anmoly_detection_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="anmoly_detection_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="anmoly_detection_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="anmoly_detection_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Anamoly detection with Machine Learning Overview</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="introduction---what-is-an-anomaly" class="level1">
<h1>Introduction - What is an Anomaly?</h1>
<p>Anomaly is a data point that deviates significantly from the rest of the data. In other words, it’s an outlier, an oddball, a data point that doesn’t seem to fit in.</p>
</section>
<section id="what-is-anomaly-detection" class="level1">
<h1>What is Anomaly Detection?</h1>
<p>Anomaly detection is like shining a spotlight on the unexpected patterns and outliers within a dataset. It separates the regular data points from the abnormal ones, allowing analysts to focus on understanding the underlying reasons or potential problems linked to these anomalies. Applications of anomaly detection can be found in many fields, such as fraud detection, network security, preventive maintenance, healthcare monitoring, and quality control.</p>
<p>While traditional methods can identify some anomalies, they often fall short when dealing with complex, high-dimensional data or nuanced patterns. Here’s why ML shines in anomaly detection:</p>
<p>1.<strong>Handling Complexity:</strong> Real-world data is messy. It’s a tangled web of interconnected variables, subtle relationships, and hidden dependencies. Traditional methods, like defining thresholds or comparing to averages, struggle to capture these complexities. ML models, however, can learn these intricate patterns and identify anomalies even when they’re disguised within the noise.</p>
<p>2.<strong>Adapting to Change:</strong> Data isn’t static. It constantly evolves, with new patterns emerging and old ones fading. Traditional methods are rigid, requiring manual adjustments to stay relevant. ML models, however, are self-learning. They continuously update their understanding of “normal” as new data arrives, ensuring they stay ahead of the curve and catch even the most fleeting anomalies.</p>
<p>3.<strong>Uncovering Hidden Insights:</strong> Traditional methods often treat anomalies as isolated data points. ML goes beyond just identifying them. By analyzing the context and surrounding data, it can uncover the underlying reasons behind the anomaly. This deeper understanding allows us to not just patch the leak, but also prevent future occurrences and even gain valuable insights into the system’s behavior.</p>
<p>4.<strong>Scaling with Volume:</strong> As data volumes explode, traditional methods become unwieldy and computationally expensive. ML models, on the other hand, thrive on large datasets. They can analyze vast amounts of data in real-time, making them ideal for applications like fraud detection in high-frequency transactions or anomaly detection in massive sensor networks.</p>
<p>5.<strong>Automating the Detective Work:</strong> Anomaly detection can be tedious and time-consuming. ML automates this process, freeing up human analysts to focus on more strategic tasks. The models continuously monitor the data, tirelessly searching for anomalies and raising alerts, allowing analysts to intervene only when necessary.</p>
<section id="anomaly-detection-methods" class="level2">
<h2 class="anchored" data-anchor-id="anomaly-detection-methods">Anomaly Detection Methods</h2>
<p>There are many different anomaly detection methods and strategies. The following list of approaches for finding anomalies is typical:</p>
<ol type="1">
<li><p><strong>Statistical Methods:</strong>This section accurately explains the core principle: identifying deviations from expected distributions. Examples like Z-score and Gaussian modeling are appropriate, but consider adding non-parametric tests like Kolmogorov-Smirnov for non-normal data. Limitations with these methods are they work well for univariate data or simple relationships, but struggle with complex, multivariate data.</p></li>
<li><p><strong>Machine Learning-based Methods:</strong>This section effectively contrasts supervised and unsupervised learning approaches.Examples like isolation forests and one-class SVMs are excellent choices. Consider adding deep anomaly detection models like LSTMs for time series data. Limitations with these methods are ML models require careful training data preparation and hyperparameter tuning to avoid overfitting or underfitting.</p></li>
<li><p><strong>Time-Series Analysis:</strong>This section accurately highlights the need for specialized methods for time series data. Examples like moving averages, exponential smoothing, and ARIMA models are well-suited.Consider mentioning advanced methods like seasonal ARIMA (SARIMA) for periodic patterns and Prophet for forecasting and anomaly detection.</p></li>
<li><p><strong>Clustering-based Methods:</strong>This section clearly explains the concept of identifying outliers based on clustering.Examples like k-means and DBSCAN are appropriate. Consider adding hierarchical clustering for identifying anomalies at different granularities.Limitations with these methods are clustering can be sensitive to noise and choosing the optimal number of clusters can be challenging.</p></li>
<li><p><strong>Deep Learning-based Methods:</strong>This section effectively highlights the potential of deep learning for complex patterns.Autoencoders as an example work well. Consider mentioning other relevant architectures like convolutional neural networks (CNNs) for image data and recurrent neural networks (RNNs) for sequential data.Limitations with these methods are deep learning models can be computationally expensive and require large amounts of training data.</p></li>
<li><p><strong>Ensemble Methods:</strong>This section effectively explains the idea of combining different methods for better performance.Mention specific examples of ensemble methods like bagging and boosting used in anomaly detection. Highlight the benefit of improved robustness and reduced false positives.</p></li>
</ol>
</section>
<section id="uses-of-anamoly-detection" class="level2">
<h2 class="anchored" data-anchor-id="uses-of-anamoly-detection">Uses of Anamoly Detection</h2>
<p>Here are just a few areas where anomaly detection flexes its muscles:</p>
<ol type="1">
<li><p><strong>Financial Fraud:</strong> Credit card transactions, loan applications, and stock market activity – the world of finance is rife with potential fraud. Anomaly detection acts as a hawk-eyed watchdog, identifying suspicious patterns like sudden spikes in spending, unusual account behavior, or coordinated market manipulation. By catching these anomalies early, we can save millions, safeguard investments, and bring bad actors to justice.</p></li>
<li><p><strong>Cybersecurity:</strong> Our digital world is constantly under siege from malicious actors. Anomaly detection stands guard at the gates, analyzing network traffic, login attempts, and system activity. From identifying DDoS attacks to spotting malware infiltration attempts, it acts as a silent guardian, protecting our data, our systems, and our privacy.</p></li>
<li><p><strong>Healthcare:</strong> Anomaly detection becomes a lifesaver in the healthcare arena. By analyzing medical data like patient vitals, lab results, and imaging scans, it can identify early signs of illness, potential drug interactions, or even rare diseases. This early detection empowers doctors to intervene swiftly, potentially saving lives and improving patient outcomes.</p></li>
<li><p><strong>Manufacturing and Equipment Maintenance:</strong> Imagine a factory where machines hum harmoniously. Anomaly detection becomes a conductor, listening for subtle shifts in rhythm, vibrations, or energy consumption. By identifying equipment on the verge of failure, it prevents costly breakdowns, ensures production efficiency, and even predicts maintenance needs before they arise.</p></li>
<li><p><strong>Marketing and Customer Service:</strong> In the ever-competitive world of business, understanding your customers is key. Anomaly detection analyzes website traffic, purchase patterns, and social media sentiment. It identifies unusual buying behavior, pinpoints customer churn risk, and even uncovers hidden trends. This empowers businesses to personalize marketing campaigns, deliver exceptional customer service, and stay ahead of the competition.</p></li>
</ol>
</section>
<section id="anamoly-detection-with-example" class="level2">
<h2 class="anchored" data-anchor-id="anamoly-detection-with-example">Anamoly Detection with Example</h2>
<p>It is challenging to find data anomalies, especially when dealing with large datasets. Fortunately, the sklearn Python module has many built-in algorithms to help us solve this problem, such as Isolation Forests. Isolation Forest is an unsupervised learning algorithm that identifies anomalies by isolating outliers in the data based on the Decision Tree Algorithm. It separates the outliers by randomly selecting a feature from the given set of features and then selecting a split value between the max and min values. This random partitioning of features will produce shorter paths in trees for the anomalous data points, thus distinguishing them from the rest of the data.</p>
<p>Let’s use the sklearn Isolation Forest implementation on the same broken dataset to implement anomaly detection with PythonLets consider</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># importing the isloation forest</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> IsolationForest</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># copying dataset</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>isf_dataset <span class="op">=</span> broken_dataset.copy()</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># initializing Isolation Forest</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>clf <span class="op">=</span> IsolationForest(max_samples<span class="op">=</span><span class="st">'auto'</span>, contamination<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># training</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>clf.fit(isf_dataset)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># finding anomalies</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>isf_dataset[<span class="st">'Anomaly'</span>] <span class="op">=</span> clf.predict(isf_dataset)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># saving anomalies to a separate dataset for visualization purposes</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>anomalies <span class="op">=</span> isf_dataset.query(<span class="st">'Anomaly == -1'</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.graph_objects <span class="im">as</span> go</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>b1 <span class="op">=</span> go.Scatter(x<span class="op">=</span>isf_dataset.index.astype(<span class="bu">str</span>),</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                y<span class="op">=</span>isf_dataset[<span class="st">'Sales'</span>],</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>                name<span class="op">=</span><span class="st">"Dataset"</span>,</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>                mode<span class="op">=</span><span class="st">'markers'</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>               )</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>b2 <span class="op">=</span> go.Scatter(x<span class="op">=</span>anomalies.index.astype(<span class="bu">str</span>),</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>                y<span class="op">=</span>anomalies[<span class="st">'Sales'</span>],</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>                name<span class="op">=</span><span class="st">"Anomalies"</span>,</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>                mode<span class="op">=</span><span class="st">'markers'</span>,</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>                marker<span class="op">=</span><span class="bu">dict</span>(color<span class="op">=</span><span class="st">'red'</span>, size<span class="op">=</span><span class="dv">6</span>,</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>                            line<span class="op">=</span><span class="bu">dict</span>(color<span class="op">=</span><span class="st">'red'</span>, width<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>               )</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>layout <span class="op">=</span> go.Layout(</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"Isolation Forest results"</span>,</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    yaxis_title<span class="op">=</span><span class="st">'Sales'</span>,</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    xaxis_title<span class="op">=</span><span class="st">'Date'</span>,</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    hovermode<span class="op">=</span><span class="st">'closest'</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [b1, b2]</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> go.Figure(data<span class="op">=</span>data, layout<span class="op">=</span>layout)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>fig.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Finally, anomaly detection shines by harnessing the power of machine learning to unearth the hidden stories within data. Whether it’s uncovering fraudulent transactions, predicting equipment failures, or even detecting rare diseases, its applications span countless fields. Both supervised and unsupervised learning methods play a crucial role, with Isolation Forests excelling at isolating individual outliers and One-Class SVMs adept at identifying patterns deviating from normality. Autoencoders and Gaussian Mixture Models also join the arsenal, each with its own strengths in revealing hidden anomalies. Statistical methods and rule-based approaches offer valuable tools as well, showcasing the versatility of anomaly detection.</p>
<p>But the journey doesn’t end here. As data volumes explode and patterns become increasingly complex, the quest for ever-more sophisticated anomaly detection methods continues. Time-series data demands specialized techniques like ARIMA and LSTMs, while deep learning models push the boundaries of what’s possible.</p>
<p>So, embrace the anomaly, delve into its mysteries, and unlock the hidden potential it holds. The future of anomaly detection is bright, and it’s a future where your insights can make a real difference.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>